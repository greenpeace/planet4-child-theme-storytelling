/*
# Welcome to the task runner that will change your life.
*/

/*
# Here we require all the node modules we need to complete our tasks.
*/
var gulp         = require('gulp'),                  // https://github.com/gulpjs/gulp/blob/master/docs/getting-started.md
	gutil        = require('gulp-util'),             // https://www.npmjs.com/package/gulp-util
	uglify       = require('gulp-uglify'),           // https://www.npmjs.com/package/gulp-uglify
	rename       = require('gulp-rename'),           // https://www.npmjs.com/package/gulp-rename
	assign       = require('lodash.assign'),         // https://www.npmjs.com/package/lodash.assign
	eslint       = require('gulp-eslint'),           // https://www.npmjs.com/package/gulp-eslint
	browserify   = require('browserify'),            // http://browserify.org/
	watchify     = require('watchify'),              // http://gulpjs.org/recipes/fast-browserify-builds-with-watchify.html
	source       = require('vinyl-source-stream'),   // https://www.npmjs.com/package/vinyl-source-stream
	buffer       = require('vinyl-buffer'),          // https://www.npmjs.com/package/vinyl-buffer
	sass         = require('gulp-sass'),             // https://www.npmjs.com/package/gulp-sass
	sourcemaps   = require('gulp-sourcemaps'),       // https://www.npmjs.com/package/gulp-sourcemaps
	postcss      = require('gulp-postcss'),          // https://www.npmjs.com/package/gulp-postcss
	//browserSync  = require('browser-sync').create(), // https://www.browsersync.io/
	//reload       = browserSync.reload;               // Turns reload function into variable
	path         = require('path'),                  // https://www.npmjs.com/package/path
	userpath     = path.resolve().split(path.sep),   // splits path
	svgcss       = require('gulp-svg-css'),          // https://www.npmjs.com/package/gulp-svg-css
	svgmin       = require('gulp-svgmin'),           // https://www.npmjs.com/package/gulp-svgmin
	svgstore     = require('gulp-svgstore'),         // https://www.npmjs.com/package/gulp-svgstore
	inject       = require('gulp-inject'),           // https://www.npmjs.com/package/gulp-inject
	del          = require('del'),                   // https://www.npmjs.com/package/del
	imagemin     = require('gulp-imagemin'),         // https://www.npmjs.com/package/gulp-imagemin
	exec         = require('child_process').exec;    // https://nodejs.org/api/child_process.html
	imageDataURI = require('gulp-image-inline'),     // https://www.npmjs.com/package/gulp-inline-image
	concat       = require('gulp-concat'),           // https://www.npmjs.com/package/gulp-concat
	debowerify   = require('debowerify'),            // https://www.npmjs.com/package/debowerify
	argv   	     = require('yargs').argv;            // https://www.npmjs.com/package/yargs

// Generates Port Number When First Run ( Numbers 3000 through 4000 In Increments Of 10)
var portGenerator = Math.round((Math.random() * 1000 + 3000) / 10) * 10;

/*
 * Path Variables
 */
var paths = {
	imgs: {
		src: '_src/img/**/*.{png,jpg}',
		template: '_src/img/optimize/template-img/**/*.{png,jpg}',
		media: '_src/img/optimize/media-img/*',
		media_dest: '_src/img/optimize/media-img/',
		proc_dest: '_src/img/optimize/processed/',
		dest: 'images'
	},
	svgs: {
		src: '_src/img/svg/**/*.svg',
		dest: '_src/scss/general'
	},
	sprite: {
		src: '_src/img/sprite/**/*.{png,jpg}',
		dest: '_src/scss/general'
	},
	styles: {
		src: '_src/scss/**/*.{sass,scss}',
		dest: 'css'
	},
	scripts: {
		src: '_src/js/**/*.js',
		dest: 'js'
	},
	html: {
		src: ['**/*.{php,inc}', '!*safe_save*'] // files with safe_save are generated by some editors when saving the file
	},
	phpconfig: 'inc/gulp-config.inc'
};

// Clean Task
function clean(cb) {
	return del([
		'css/*',
		'!css/*.min.css',
		'js/*',
		'!js/*.min.js',
		'!js/*.min.js.map',
		paths.phpconfig
	]);
}

// Clean Task for Build
function clean_build(cb) {
	return del([
		'css/*.min.css',
		'js/*.min.js',
		'js/*.min.js.map',
		paths.phpconfig
	]);
}

// Clean PHP config only
function clean_php() {
	return del(paths.phpconfig);
}

// BrowserSync Task
// function serve(cb) {
// 	var browserSync_config = {
// 		host: userpath[4] + '.' + userpath[2] + '.cshp.co',
// 		proxy: {
// 			target: userpath[4] + '.' + userpath[2] + '.cshp.co',
// 			proxyReq: function (proxyReq) {
// 				// Set a request header that will signify to the server that we're
// 				// going through Browsersync.
// 				proxyReq.setHeader('X-Browsersynced', 'Heck yeah');
// 			}
// 		},
// 		port: portGenerator,
// 		ghostMode: false
// 	};

// 	// Use HTTPS when generating a Browsersync local site so port forwarding works
// 	if ( argv.https || argv.secure ) {
// 		browserSync_config.https = true;
// 	}

// 	browserSync.init(browserSync_config);

// 	// Write the BROWSERSYNC_PORT constant to an .inc file.
// 	require('fs').writeFileSync(paths.phpconfig, '<?php define( "BROWSERSYNC_PORT", ' + portGenerator + ' );');

// 	watch();

// 	// Trap Ctrl-C signal and clean up the file containing the BROWSERSYNC_PORT
// 	// constant before exiting.
// 	process.once('SIGINT', function () {
// 		clean_php().then(function () {
// 			console.log('Removed ' + paths.phpconfig + ' file.');
// 			return process.exit();
// 		});
// 	});

// 	cb();
// }

// Styles Tasks

// PostCSS Processors
var processors = [
	require('postcss-short')({ /* options */ }),
	require('postcss-sorting')({ /* options */ }),
	require('autoprefixer')({ browsers: ['last 3 versions'] })
];

var processorsProd = [
	require('postcss-short')({ /* options */ }),
	require('postcss-sorting')({ /* options */ }),
	require('autoprefixer')({ browsers: ['last 3 versions'] }),
	require('cssnano')({
		zindex: false // Don't change z-index values when minifying!
	})
];

// Compile Styles for Dev
function styles() {
	return gulp.src(paths.styles.src)
		.pipe(sourcemaps.init())
		.pipe(sass().on('error', sass.logError))
		.pipe(postcss(processors))
		.pipe(sourcemaps.write('./maps', { includeContent: false, sourceRoot: '/_src/scss' }))
		.pipe(gulp.dest(paths.styles.dest))
		//.pipe(browserSync.stream({ match: '**/*.css' }));
}

// Compile Styles for Production
function stylesProd() {
	return gulp.src(paths.styles.src)
		.pipe(sass().on('error', sass.logError))
		.pipe(postcss(processorsProd))
		.pipe(rename({
			suffix: '.min'
		}))
		.pipe(gulp.dest(paths.styles.dest));
}

// Lint Task
function lint() {
	return gulp.src([paths.scripts.src, '!node_modules/**/*.js', '!_src/js/vendor/**/*.js'])
		.pipe(eslint())
		.pipe(eslint.format('stylish'));
}

// Scripts Task
function scripts(cb) {
	bundle();
	cb();
}

// Browserify options
var browserifyOpts = {
	cache: {},
	packageCache: {},
	entries: ['./_src/js/index.js'],
	paths: ['./node_modules', './_src/js/'],
	debug: true
};
var opts = assign({}, watchify.args, browserifyOpts);
var b = watchify(browserify(opts));

// Allows bower packages to be used with browserify
b.transform(debowerify);
// When a JS file is updated, rebundle and reload browser
b.on('update', gulp.series(bundle, reload));
// Log info, includes error info
b.on('log', gutil.log);

// Dev Build
function bundle() {
	return b.bundle()
		.on('error', gutil.log.bind(gutil, 'Browserify Error'))
		.pipe(source('crate.js'))
		.pipe(buffer())
		.pipe(sourcemaps.init({ loadMaps: true }))
		.pipe(uglify().on('error', gutil.log))
		.pipe(sourcemaps.write('./maps', { includeContent: false, sourceRoot: '/_src/js' }))
		.pipe(gulp.dest('./js'));
}

// Production Build (No watching, minify all the things)
function scriptsProd(bool) {

	// Set scriptName var default to true
	var scriptName = 'crate.min.js';
	// You can pass in a false value to function param bool to render crate.js without watching
	if (bool === false) {
		scriptName = 'crate.js';
	}

	var bundleProd = browserify({
		cache: {},
		packageCache: {},
		entries: ['./_src/js/index.js'],
		paths: ['./node_modules', './_src/js/'],
		debug: true
	}).transform(debowerify);

	return bundleProd.bundle()
		.on('error', gutil.log.bind(gutil, 'Browserify Error'))
		.pipe(source(scriptName))
		.pipe(buffer())
		.pipe(sourcemaps.init({ loadMaps: true }))
		.pipe(uglify().on('error', gutil.log))
		.pipe(sourcemaps.write('./maps', { includeContent: false, sourceRoot: '/_src/js' }))
		.pipe(gulp.dest('./js'));
}

// Runs browserify without watchify and outputs crate.js and crate.js.map
function scriptsNoWatch(cb) {
	scriptsProd(false);
	cb();
}

///////////////////
// Image/SVG tasks
///////////////////

// Optimize SVG Task
function optimizesvg() {
	return gulp.src(paths.svgs.src)
		.pipe(svgmin(function (file) {
			var prefix = path.basename(file.relative, path.extname(file.relative));
			return {
				plugins: [{
					cleanupIDs: {
						prefix: prefix + '-',
						minify: true
					}
				}]
			}
		}));
}

// SVG Style Task
function svgstyle() {
	return gulp.src(paths.svgs.src)
		.pipe(svgcss({ fileName: '_icons', fileExt: 'scss', cssPrefix: 'icon-', addSize: true }))
		.pipe(gulp.dest(paths.svgs.dest));
}

// SVG Inline Task
function svginline() {
	var svgs = gulp
		.src(paths.svgs.src)
		.pipe(rename({ prefix: 'icon-' }))
		.pipe(svgstore({ inlineSvg: true }));

	function fileContents(filePath, file) {
		return file.contents.toString();
	}

	return gulp
		.src('./template-parts/header-svg.php')
		.pipe(inject(svgs, { transform: fileContents }))
		.pipe(gulp.dest('./template-parts/'));
}

var svgcompile = gulp.series(svgstyle, styles);
var svg = gulp.series(optimizesvg, gulp.parallel(svgcompile, svginline));

// Sprite Task
function sprite() {
	return gulp.src(paths.sprite.src)
		.pipe(imagemin())
		.pipe(imageDataURI({
			dimension: true,
			customClass: function (className, file) {
				var customClass = 'icon-' + className;
				return customClass;
			}
		}))
		.pipe(concat('_sprite.scss'))
		.pipe(gulp.dest(paths.sprite.dest));
}

function clean_original_template_image(cb) {
	return del(paths.imgs.template);
}

// Backup Original Image for Template Task
function backuptemplate() {
	return gulp.src(paths.imgs.template)
		.pipe(gulp.dest(paths.imgs.proc_dest));
}

// Optimize Image for Template Task
function optimizetemplate() {
	return gulp.src(paths.imgs.template)
		.pipe(imagemin())
		.pipe(gulp.dest(paths.imgs.dest))
		.on('end', function () {
			clean_original_template_image();
		});
}

var templateimages = gulp.series(backuptemplate, optimizetemplate);

// Media Uploads Task

function mediaupload(cb) {
	exec('wp media import ' + paths.imgs.media, function (err, stdout, stderr) {
		console.log(stdout);
		console.log(stderr);
		cb(err);
	});
}

// Clean uploaded images
function cleanmedia(cb) {
	return del(paths.imgs.media);
}

var media = gulp.series(mediaupload, cleanmedia);

function screenshot(cb) {
	Pageres = require('pageres');
	del('../crate-child/screenshot.png', { force: true }).then(paths => {
		const pageres = new Pageres({ filename: 'screenshot', delay: 4 })
			.src(userpath[4] + '.' + userpath[2] + '.cshp.co', ['1200x900'], { crop: true })
			.dest('../crate-child')
			.run()
			.then(() => console.log('done'));
		cb(console.log('waiting for screenshot...'));
	});
}


// Watch Task
function watch() {
	gulp.watch(paths.scripts.src, scripts);
	gulp.watch(paths.styles.src, styles);
	gulp.watch(paths.sprite.src, sprite);
	gulp.watch(paths.imgs.template, optimizetemplate);
	gulp.watch(paths.svgs.src, svg);
	var watchhtml = gulp.watch(paths.html.src);
	watchhtml.on('add', reload);
	watchhtml.on('change', reload);
	watchhtml.on('unlink', reload);
	var watchmedia = gulp.watch(paths.imgs.media, { awaitWriteFinish: true });
	watchmedia.on('add', media);
	var watchtemplate = gulp.watch(paths.imgs.template, { awaitWriteFinish: true });
	watchtemplate.on('add', templateimages);
}

// Export functions to declare tasks
exports.clean = clean;
exports.clean_build = clean_build;
exports.cleanmedia = cleanmedia;
exports.lint = lint;
exports.styles = styles;
exports.stylesProd = stylesProd;
exports.scripts = scripts;
exports.scriptsNoWatch = scriptsNoWatch;
exports.scriptsProd = scriptsProd;
exports.sprite = sprite;
exports.backuptemplate = backuptemplate;
exports.optimizetemplate = optimizetemplate;
exports.mediaupload = mediaupload;
exports.optimizesvg = optimizesvg;
exports.svgstyle = svgstyle;
exports.svginline = svginline;
exports.serve = serve;
exports.watch = watch;
exports.screenshot = screenshot;

var build = gulp.series(clean, svginline, svgstyle, gulp.parallel(styles, scripts, sprite, templateimages));
var dev = gulp.series(build, serve);
var prod = gulp.series(clean_build, svginline, svgstyle, gulp.parallel(stylesProd, scriptsProd, sprite, templateimages, screenshot));
var devNoWatch = gulp.series(scriptsNoWatch, styles);

// Build Task: Compile assets for production
gulp.task('build', prod);

// Build-dev Task: Compile JS and CSS for demo
gulp.task('build-dev', devNoWatch);

// Default Task: Compile un-minified assets and watch
gulp.task('default', dev);